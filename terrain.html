<!DOCTYPE html>
<html>
<head>
  <title>Perlin, Billow, Ridged Multifractal, and SingleValueFractalFBM Noise Heightmaps</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
    }
    canvas {
      border: 1px solid black;
      margin-top: 5px;
    }
    .canvas-title {
      text-align: center;
    }
  </style>
</head>
<body>
    <div>
      <div class="canvas-container">
        <div class="canvas-title">Perlin Noise</div>
        <canvas id="perlinCanvas" width="500" height="500"></canvas>
      </div>
      <div class="canvas-container">
        <div class="canvas-title">Billow Noise</div>
        <canvas id="billowCanvas" width="500" height="500"></canvas>
      </div>
    </div>
    <div>
      <div class="canvas-container">
        <div class="canvas-title">Ridged Multifractal Noise</div>
        <canvas id="multifractalCanvas" width="500" height="500"></canvas>
      </div>
      <div class="canvas-container">
        <div class="canvas-title">FBM Variant 1</div>
        <canvas id="fbmCanvas1" width="500" height="500"></canvas>
      </div>
    </div>
    <div>
      <div class="canvas-container">
        <div class="canvas-title">FBM Variant 2</div>
        <canvas id="fbmCanvas2" width="500" height="500"></canvas>
      </div>
      <div class="canvas-container">
        <div class="canvas-title">FBM Variant 3</div>
        <canvas id="fbmCanvas3" width="500" height="500"></canvas>
      </div>  
    </div>

  <script>
    class Noise {
      constructor(seed=Date.now()) {

        this.seedN = seed;
        this.seedK = seed;


        this.grad3 = [
          [1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0],
          [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1],
          [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]
        ];
        this.p = [];
        this.seed(seed); // Seed the permutation array
        this.perm = [];
        for (let i = 0; i < 512; i++) {
          this.perm[i] = this.p[i & 255]; // Repeat the permutation
        }
      }

      seed(seed) {
        const random = this.xorshift(seed);
        for (let i = 0; i < 256; i++) {
          this.p[i] = i;
        }
        for (let i = 255; i > 0; i--) {
          const j = Math.floor(random() * (i + 1));
          [this.p[i], this.p[j]] = [this.p[j], this.p[i]];
        }
      }

      seededRandom() {
        this.seedK += Math.E;
        const x = 1000000000*Math.sin(this.seedK);
        return x - Math.floor(x);
      }

      resetSeed() {
        this.seedK = this.seedN;
      }

      xorshift(seed) {
        let x = seed;
        return function() {
          x ^= x << 13;
          x ^= x >> 17;
          x ^= x << 5;
          return (x < 0 ? 1 + ~x : x) / 0xFFFFFFFF;
        };
      }

      dot(g, x, y, z) {
        return g[0] * x + g[1] * y + g[2] * z;
      }

      mix(a, b, t) {
        return (1.0 - t) * a + t * b;
      }

      fade(t) {
        return t * t * t * (t * (t * 6 - 15) + 10);
      }

      noise(x, y, z) {
        let X = Math.floor(x) & 255;
        let Y = Math.floor(y) & 255;
        let Z = Math.floor(z) & 255;

        x -= Math.floor(x);
        y -= Math.floor(y);
        z -= Math.floor(z);

        let u = this.fade(x);
        let v = this.fade(y);
        let w = this.fade(z);

        let A = this.perm[X] + Y;
        let AA = this.perm[A] + Z;
        let AB = this.perm[A + 1] + Z;
        let B = this.perm[X + 1] + Y;
        let BA = this.perm[B] + Z;
        let BB = this.perm[B + 1] + Z;

        return this.mix(this.mix(this.mix(this.dot(this.grad3[this.perm[AA] % 12], x, y, z),
          this.dot(this.grad3[this.perm[BA] % 12], x - 1, y, z), u),
          this.mix(this.dot(this.grad3[this.perm[AB] % 12], x, y - 1, z),
          this.dot(this.grad3[this.perm[BB] % 12], x - 1, y - 1, z), u), v),
          this.mix(this.mix(this.dot(this.grad3[this.perm[AA + 1] % 12], x, y, z - 1),
          this.dot(this.grad3[this.perm[BA + 1] % 12], x - 1, y, z - 1), u),
          this.mix(this.dot(this.grad3[this.perm[AB + 1] % 12], x, y - 1, z - 1),
          this.dot(this.grad3[this.perm[BB + 1] % 12], x - 1, y - 1, z - 1), u), v), w);
      }
    }
    
    class SimplexNoise {
        constructor(seed=Date.now()) {

            this.seedN = seed;
            this.seedK = seed;
            this.perm = new Uint8Array(512);
            this.grad3 = [
                [1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0],
                [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1],
                [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]
            ];

            this.seed(seed);
        }

        seed(seed) {
            const random = this.xorshift(seed);
            for (let i = 0; i < 256; i++) {
                this.perm[i] = i;
            }
            for (let i = 255; i > 0; i--) {
                const j = Math.floor(random() * (i + 1));
                [this.perm[i], this.perm[j]] = [this.perm[j], this.perm[i]];
            }
            for (let i = 0; i < 256; i++) {
                this.perm[i + 256] = this.perm[i];
            }
        }

        seededRandom() {
          this.seedK += Math.E;
          const x = 1000000000*Math.sin(this.seedK);
          return x - Math.floor(x);
        }

        resetSeed() {
          this.seedK = this.seedN;
        }


        xorshift(seed) {
            let x = seed;
            return function() {
                x ^= x << 13;
                x ^= x >> 17;
                x ^= x << 5;
                return (x < 0 ? 1 + ~x : x) / 0xFFFFFFFF;
            };
        }

        dot(g, x, y) {
            return g[0] * x + g[1] * y;
        }

        noise(xin, yin) {
            const F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
            const G2 = (3.0 - Math.sqrt(3.0)) / 6.0;
            let n0, n1, n2; // Noise contributions from the three corners

            // Skew the input space to determine which simplex cell we're in
            const s = (xin + yin) * F2; // Hairy factor for 2D
            const i = Math.floor(xin + s);
            const j = Math.floor(yin + s);
            const t = (i + j) * G2;
            const X0 = i - t; // Unskew the cell origin back to (x,y) space
            const Y0 = j - t;
            const x0 = xin - X0; // The x,y distances from the cell origin
            const y0 = yin - Y0;

            // For the 2D case, the simplex shape is an equilateral triangle.
            // Determine which simplex we are in.
            let i1, j1; // Offsets for the second (middle) corner of simplex in (i,j) coordinates
            if (x0 > y0) { // Lower triangle, XY order: (0,0)->(1,0)->(1,1)
                i1 = 1;
                j1 = 0;
            } else { // Upper triangle, YX order: (0,0)->(0,1)->(1,1)
                i1 = 0;
                j1 = 1;
            }

            // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
            // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
            // c = (3-sqrt(3))/6

            const x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coordinates
            const y1 = y0 - j1 + G2;
            const x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coordinates
            const y2 = y0 - 1.0 + 2.0 * G2;

            // Work out the hashed gradient indices of the three simplex corners
            const ii = i & 255;
            const jj = j & 255;
            const gi0 = this.perm[ii + this.perm[jj]] % 12;
            const gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;
            const gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12;

            // Calculate the contribution from the three corners
            let t0 = 0.5 - x0 * x0 - y0 * y0;
            if (t0 < 0) n0 = 0.0;
            else {
                t0 *= t0;
                n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0); // (x,y) of grad3 used for 2D gradient
            }

            let t1 = 0.5 - x1 * x1 - y1 * y1;
            if (t1 < 0) n1 = 0.0;
            else {
                t1 *= t1;
                n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
            }

            let t2 = 0.5 - x2 * x2 - y2 * y2;
            if (t2 < 0) n2 = 0.0;
            else {
                t2 *= t2;
                n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);
            }

            // Add contributions from each corner to get the final noise value.
            // The result is scaled to return values in the interval [-1,1].
            return 70.0 * (n0 + n1 + n2);
        }
    }

    

    class PerlinNoise extends Noise {
      generateNoise(x, y, z, zoom = 1.0, octaves = 6, lacunarity = 2.0, gain = 0.5, shift=0) {
        x /= zoom;
        y /= zoom;
        z /= zoom;

        let sum = 0;
        let amp = 1.0;
        let freq = 1.0;

        let angle = this.seedN * 2*Math.PI; //start at random angle;
        let angleIncr = Math.PI / 4;
        const angleIncrement = Math.PI/4;


        for (let i = 0; i < octaves; i++) {
            sum += this.noise(x * freq, y * freq, z * freq) * amp;
            freq *= lacunarity;
            amp *= gain;
          
            // Apply rotation to the coordinates
            const cosAngle = Math.cos(angle);
            const sinAngle = Math.sin(angle);

            const newX = x * cosAngle - y * sinAngle;
            const newY = x * sinAngle + y * cosAngle;

            x = newX;
            y = newY;
            angle += angleIncrement;

            // Apply shift to the coordinates
            x += shift;
            y += shift;
        }

        return sum;
      }
    }

    class BillowNoise extends Noise {
      generateNoise(x, y, z, zoom = 1.0, octaves = 6, lacunarity = 2.0, gain = 0.5, shift=0) {
        x /= zoom;
        y /= zoom;
        z /= zoom;

        let sum = 0;
        let amp = 1.0;
        let freq = 1.0;

        let angle = this.seedN * 2*Math.PI; //start at random angle;
        const angleIncrement = Math.PI/4;

        for (let i = 0; i < octaves; i++) {
            const noiseValue = this.noise(x * freq, y * freq, z * freq);
            sum += (2 * Math.abs(noiseValue) - 1) * amp;

            freq *= lacunarity;
            amp *= gain;

            // Apply rotation to the coordinates
            const cosAngle = Math.cos(angle);
            const sinAngle = Math.sin(angle);

            const newX = x * cosAngle - y * sinAngle;
            const newY = x * sinAngle + y * cosAngle;

            x = newX;
            y = newY;
            angle += angleIncrement;

            // Apply shift to the coordinates
            x += shift;
            y += shift;
        }

        return sum;
      }
    }

    class RidgedMultifractalNoise extends Noise {
      generateNoise(x, y, z, zoom = 1.0, octaves = 6, lacunarity = 2.0, gain = 0.75, shift=0, exp1 = 1.0, exp2 = 1.0) {
        x /= zoom;
        y /= zoom;
        z /= zoom;

        let sum = 1 - Math.abs(this.noise(x, y, z));
        let amp = 1.0;

        
        let angle = this.seedN * 2*Math.PI; //start at random angle;
        let angleIncr = Math.PI/4;
        for (let i = 1; i < octaves; i++) {
            x *= lacunarity;
            y *= lacunarity;
            z *= lacunarity;

            amp *= gain;

            //add some variation on the fractal pattern with exponents
            let noise = Math.abs(this.noise(x, y, z));
            let noiseValue = 1 - (Math.pow(noise, exp2));
            noiseValue = Math.pow(noiseValue, exp1);
            
            sum -= noiseValue * amp;
          
            //adds some rotation to vary the textures more 
            let lastX;
            x = x * Math.cos(angle) + x * Math.sin(angle);
            y = y * Math.sin(angle) + y * Math.cos(angle); 
            angle += angleIncr;

            x += shift;
            y += shift;
        }

        return sum;
      }
    }

    class FractalBrownianMotion extends SimplexNoise {
        fbm(x, y, z, zoom = 1.0, octaves = 6, lacunarity = 2.0, gain = 0.5, shift = 100) {
            x /= zoom;
            y /= zoom;
            z /= zoom;

            let sum = 0;
            let amplitude = 1.0;
            let frequency = 1.0;
            let maxValue = 0;

            for (let i = 0; i < octaves; i++) {
                sum += amplitude * this.noise(x * frequency, y * frequency, z * frequency);
                maxValue += amplitude;

                frequency *= lacunarity;
                amplitude *= gain;

                x += shift;
                y += shift;
            }

            return sum / maxValue;
        }

        generateNoise(x, y, z, zoom = 1.0, octaves = 6, lacunarity = 2.0, gain = 0.5, shift = 100) {
            // Initial FBM pass
            let fbm1 = this.fbm(x, y, z, zoom, octaves, lacunarity, gain, shift);

            // Recursive FBM pass using the output of the initial FBM
            let fbm2 = this.fbm(fbm1 * zoom, fbm1 * zoom, fbm1 * zoom, zoom, octaves, lacunarity, gain, shift);

            return fbm2;
        }
      }

      class FractalBrownianMotion2 extends SimplexNoise {
        fbm(x, y, z, zoom = 1.0, octaves = 6, lacunarity = 2.0, gain = 0.5, shift = 100) {
            x /= zoom;
            y /= zoom;
            z /= zoom;

            let sum = 0;
            let amplitude = 1.0;
            let frequency = 1.0;
            let maxValue = 0;

            for (let i = 0; i < octaves; i++) {
                sum += amplitude * this.noise(x * frequency, y * frequency, z * frequency);
                maxValue += amplitude;

                frequency *= lacunarity;
                amplitude *= gain;

                x += shift;
                y += shift;
            }

            return sum / maxValue;
        }

        generateNoise(x, y, z, zoom = 1.0, octaves = 6, lacunarity = 2.0, gain = 0.5, shift = 100) {
            // Initial FBM pass
            let fbm1 = this.fbm(x, y, z, zoom, octaves, lacunarity, gain, shift);

            // Second FBM pass using the output of the initial FBM
            let fbm2 = this.fbm(fbm1 * zoom, fbm1 * zoom, fbm1 * zoom, zoom, octaves, lacunarity, gain, shift);

            // Third FBM pass using the output of the second FBM
            let fbm3 = this.fbm(x + fbm2 * zoom, y + fbm2 * zoom, z + fbm2 * zoom, zoom, octaves, lacunarity, gain, shift);

            return fbm3;
        }
    }

    class FractalBrownianMotion3 extends SimplexNoise {
        fbm(x, y, z, zoom = 1.0, octaves = 6, lacunarity = 2.0, gain = 0.5, shift = 100) {
            x /= zoom;
            y /= zoom;
            z /= zoom;

            let sum = 0;
            let amplitude = 1.0;
            let frequency = 1.0;
            let maxValue = 0;

            for (let i = 0; i < octaves; i++) {
                sum += amplitude * this.noise(x * frequency, y * frequency, z * frequency);
                maxValue += amplitude;

                frequency *= lacunarity;
                amplitude *= gain;

                x += shift;
                y += shift;
            }

            return sum / maxValue;
        }

        generateNoise(x, y, z, zoom = 1.0, octaves = 6, lacunarity = 2.0, gain = 0.5, shift = 100) {
            // Initial FBM pass
            let fbm1 = this.fbm(x, y, z, zoom, octaves, lacunarity, gain, shift);

            // Second FBM pass using the output of the initial FBM
            let fbm2 = this.fbm(x + fbm1 * zoom, y + fbm1 * zoom, z + fbm1 * zoom, zoom, octaves, lacunarity, gain, shift);

            // Third FBM pass using the output of the second FBM
            let fbm3 = this.fbm(x + fbm2 * zoom, y + fbm2 * zoom, z + fbm2 * zoom, zoom, octaves, lacunarity, gain, shift);

            return fbm3;
        }
    }
    

    document.addEventListener('DOMContentLoaded', function() {
      const perlinCanvas = document.getElementById('perlinCanvas');
      const billowCanvas = document.getElementById('billowCanvas');
      const multifractalCanvas = document.getElementById('multifractalCanvas');
      const fbmCanvas = document.getElementById('fbmCanvas1');
      const fbmCanvas2 = document.getElementById('fbmCanvas2');
      const fbmCanvas3 = document.getElementById('fbmCanvas3');

      const perlinCtx = perlinCanvas.getContext('2d');
      const billowCtx = billowCanvas.getContext('2d');
      const multifractalCtx = multifractalCanvas.getContext('2d');
      const fbmCtx = fbmCanvas.getContext('2d');
      const fbmCtx2 = fbmCanvas2.getContext('2d');
      const fbmCtx3 = fbmCanvas3.getContext('2d');

      const width = perlinCanvas.width;
      const height = perlinCanvas.height;

      const zoom = 100; // Adjust zoom for more zoomed-in noise pattern
      const octaves = 8; // Number of octaves for the noise
      const lacunarity = 2.0; // Lacunarity for the noise
      const gain = 0.5; // Gain for the noise
      const shift = 0; //e.g. a time shift

      const perlinHeightmap = new Float32Array(width * height);
      const billowHeightmap = new Float32Array(width * height);
      const ridgedHeightmap = new Float32Array(width * height);
      const fbmHeightmap = new Float32Array(width * height);
      const fbmHeightmap2 = new Float32Array(width * height);
      const fbmHeightmap3 = new Float32Array(width * height);

      const perlin = new PerlinNoise(12345); // Set a seed for reproducibility
      const billow = new BillowNoise(12345); // Set a seed for reproducibility
      const ridged = new RidgedMultifractalNoise(12345); // Set a seed for reproducibility
      const fbm = new FractalBrownianMotion(12345); // Set a seed for reproducibility
      const fbm2 = new FractalBrownianMotion2(12345); // Set a seed for reproducibility
      const fbm3 = new FractalBrownianMotion3(12345); // Set a seed for reproducibility

      let iterateCanvas = (
        noiseGen, 
        heightmap, 
        ctx,
      
        zoom,
        octaves,
        lacunarity,
        gain,
        shift
      ) => {

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
              // Generate Perlin noiseGen
            const noiseValue = noiseGen.generateNoise(x, y, 0, zoom, octaves, lacunarity, gain, shift); //2d
            heightmap[y * width + x] = noiseValue;

            const color = Math.floor((noiseValue + 1) * 128);
            ctx.fillStyle = `rgb(${color}, ${color}, ${color})`;
            ctx.fillRect(x, y, 1, 1);
          }
        }
      }


      iterateCanvas(perlin,perlinHeightmap,perlinCtx, zoom,octaves,lacunarity,gain,shift);
      iterateCanvas(billow,billowHeightmap,billowCtx, zoom,octaves,lacunarity,gain-0.2,shift);
      iterateCanvas(ridged,ridgedHeightmap,multifractalCtx, zoom,octaves,lacunarity,gain+0.1,shift);
      iterateCanvas(fbm,fbmHeightmap,fbmCtx, zoom,octaves,lacunarity,gain,shift);
      iterateCanvas(fbm2,fbmHeightmap2,fbmCtx2, zoom,octaves,lacunarity,gain,shift);
      iterateCanvas(fbm3,fbmHeightmap3,fbmCtx3, zoom,octaves,lacunarity,gain,shift);

    //   console.log('Perlin Heightmap:', perlinHeightmap);
    //   console.log('Billow Heightmap:', billowHeightmap);
    //   console.log('Ridged Heightmap:', ridgedHeightmap);
    //   console.log('FBM Heightmap:', fbmHeightmap);
    });
  </script>
</body>
</html>