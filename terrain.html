<!DOCTYPE html>
<html>
<head>
  <title>Perlin, Billow, Ridged Multifractal, and SingleValueFractalFBM Noise Heightmaps</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
    }
    .canvas-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 10px;
    }
    canvas {
      border: 1px solid black;
      margin-top: 5px;
    }
    .canvas-title {
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="canvas-container">
    <div class="canvas-title">Perlin Noise</div>
    <canvas id="perlinCanvas" width="500" height="500"></canvas>
  </div>
  <div class="canvas-container">
    <div class="canvas-title">Billow Noise</div>
    <canvas id="billowCanvas" width="500" height="500"></canvas>
  </div>
  <div class="canvas-container">
    <div class="canvas-title">Ridged Multifractal Noise</div>
    <canvas id="multifractalCanvas" width="500" height="500"></canvas>
  </div>
  <div class="canvas-container">
    <div class="canvas-title">Fractal Brownian Motion w/ Simplex Noise</div>
    <canvas id="fbmCanvas" width="500" height="500"></canvas>
  </div>
  <script>
    class Noise {
      constructor(seed) {
        this.grad3 = [
          [1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0],
          [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1],
          [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]
        ];
        this.p = [];
        this.seed(seed); // Seed the permutation array
        this.perm = [];
        for (let i = 0; i < 512; i++) {
          this.perm[i] = this.p[i & 255]; // Repeat the permutation
        }
      }

      seed(seed) {
        const random = this.xorshift(seed);
        for (let i = 0; i < 256; i++) {
          this.p[i] = i;
        }
        for (let i = 255; i > 0; i--) {
          const j = Math.floor(random() * (i + 1));
          [this.p[i], this.p[j]] = [this.p[j], this.p[i]];
        }
      }

      xorshift(seed) {
        let x = seed;
        return function() {
          x ^= x << 13;
          x ^= x >> 17;
          x ^= x << 5;
          return (x < 0 ? 1 + ~x : x) / 0xFFFFFFFF;
        };
      }

      dot(g, x, y, z) {
        return g[0] * x + g[1] * y + g[2] * z;
      }

      mix(a, b, t) {
        return (1.0 - t) * a + t * b;
      }

      fade(t) {
        return t * t * t * (t * (t * 6 - 15) + 10);
      }

      noise(x, y, z) {
        let X = Math.floor(x) & 255;
        let Y = Math.floor(y) & 255;
        let Z = Math.floor(z) & 255;

        x -= Math.floor(x);
        y -= Math.floor(y);
        z -= Math.floor(z);

        let u = this.fade(x);
        let v = this.fade(y);
        let w = this.fade(z);

        let A = this.perm[X] + Y;
        let AA = this.perm[A] + Z;
        let AB = this.perm[A + 1] + Z;
        let B = this.perm[X + 1] + Y;
        let BA = this.perm[B] + Z;
        let BB = this.perm[B + 1] + Z;

        return this.mix(this.mix(this.mix(this.dot(this.grad3[this.perm[AA] % 12], x, y, z),
          this.dot(this.grad3[this.perm[BA] % 12], x - 1, y, z), u),
          this.mix(this.dot(this.grad3[this.perm[AB] % 12], x, y - 1, z),
          this.dot(this.grad3[this.perm[BB] % 12], x - 1, y - 1, z), u), v),
          this.mix(this.mix(this.dot(this.grad3[this.perm[AA + 1] % 12], x, y, z - 1),
          this.dot(this.grad3[this.perm[BA + 1] % 12], x - 1, y, z - 1), u),
          this.mix(this.dot(this.grad3[this.perm[AB + 1] % 12], x, y - 1, z - 1),
          this.dot(this.grad3[this.perm[BB + 1] % 12], x - 1, y - 1, z - 1), u), v), w);
      }
    }
    
    class SimplexNoise {
        constructor(seed) {
            this.perm = new Uint8Array(512);
            this.grad3 = [
                [1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0],
                [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1],
                [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]
            ];

            this.seed(seed);
        }

        seed(seed) {
            const random = this.xorshift(seed);
            for (let i = 0; i < 256; i++) {
                this.perm[i] = i;
            }
            for (let i = 255; i > 0; i--) {
                const j = Math.floor(random() * (i + 1));
                [this.perm[i], this.perm[j]] = [this.perm[j], this.perm[i]];
            }
            for (let i = 0; i < 256; i++) {
                this.perm[i + 256] = this.perm[i];
            }
        }

        xorshift(seed) {
            let x = seed;
            return function() {
                x ^= x << 13;
                x ^= x >> 17;
                x ^= x << 5;
                return (x < 0 ? 1 + ~x : x) / 0xFFFFFFFF;
            };
        }

        dot(g, x, y) {
            return g[0] * x + g[1] * y;
        }

        noise(xin, yin) {
            const F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
            const G2 = (3.0 - Math.sqrt(3.0)) / 6.0;
            let n0, n1, n2; // Noise contributions from the three corners

            // Skew the input space to determine which simplex cell we're in
            const s = (xin + yin) * F2; // Hairy factor for 2D
            const i = Math.floor(xin + s);
            const j = Math.floor(yin + s);
            const t = (i + j) * G2;
            const X0 = i - t; // Unskew the cell origin back to (x,y) space
            const Y0 = j - t;
            const x0 = xin - X0; // The x,y distances from the cell origin
            const y0 = yin - Y0;

            // For the 2D case, the simplex shape is an equilateral triangle.
            // Determine which simplex we are in.
            let i1, j1; // Offsets for the second (middle) corner of simplex in (i,j) coordinates
            if (x0 > y0) { // Lower triangle, XY order: (0,0)->(1,0)->(1,1)
                i1 = 1;
                j1 = 0;
            } else { // Upper triangle, YX order: (0,0)->(0,1)->(1,1)
                i1 = 0;
                j1 = 1;
            }

            // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
            // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
            // c = (3-sqrt(3))/6

            const x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coordinates
            const y1 = y0 - j1 + G2;
            const x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coordinates
            const y2 = y0 - 1.0 + 2.0 * G2;

            // Work out the hashed gradient indices of the three simplex corners
            const ii = i & 255;
            const jj = j & 255;
            const gi0 = this.perm[ii + this.perm[jj]] % 12;
            const gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;
            const gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12;

            // Calculate the contribution from the three corners
            let t0 = 0.5 - x0 * x0 - y0 * y0;
            if (t0 < 0) n0 = 0.0;
            else {
                t0 *= t0;
                n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0); // (x,y) of grad3 used for 2D gradient
            }

            let t1 = 0.5 - x1 * x1 - y1 * y1;
            if (t1 < 0) n1 = 0.0;
            else {
                t1 *= t1;
                n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1);
            }

            let t2 = 0.5 - x2 * x2 - y2 * y2;
            if (t2 < 0) n2 = 0.0;
            else {
                t2 *= t2;
                n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2);
            }

            // Add contributions from each corner to get the final noise value.
            // The result is scaled to return values in the interval [-1,1].
            return 70.0 * (n0 + n1 + n2);
        }
    }

    class FractalBrownianMotion extends SimplexNoise {
        generateNoise(x, y, z, zoom = 1.0, octaves = 6, lacunarity = 2.0, gain = 0.5) {
            x /= zoom;
            y /= zoom;
            z /= zoom;

            let sum = 0;
            let amp = 1.0;
            let freq = 1.0;

            let shift = 100;

            for (let i = 0; i < octaves; i++) {
                sum += amp * this.noise(x * freq, y * freq, z * freq);
                
                
                //adds some rotation to vary the textures more 
                x = x * Math.cos(0.5) + x*Math.sin(0.5);
                y = y * Math.sin(0.5) + y*Math.cos(0.5); 
                
                //x *= 2; y *= 2;
                
                x += shift; y += shift;
                
                freq *= lacunarity;
                amp *= gain;
            }

            return sum;
        }
    }

    class PerlinNoise extends Noise {
      generateNoise(x, y, z, zoom = 1.0, octaves = 6, lacunarity = 2.0, gain = 0.5) {
        x /= zoom;
        y /= zoom;
        z /= zoom;

        let sum = 0;
        let amp = 1.0;
        let freq = 1.0;

        for (let i = 0; i < octaves; i++) {
            sum += this.noise(x * freq, y * freq, z * freq) * amp;
            freq *= lacunarity;
            amp *= gain;
          
            //adds some rotation to vary the textures more 
            //x = x * Math.cos(0.5) + x*Math.sin(0.5);
            //y = y * Math.sin(0.5) + y*Math.cos(0.5); 
        }

        return sum;
      }
    }

    class BillowNoise extends Noise {
      generateNoise(x, y, z, zoom = 1.0, octaves = 6, lacunarity = 2.0, gain = 0.5) {
        x /= zoom;
        y /= zoom;
        z /= zoom;

        let sum = 0;
        let amp = 1.0;
        let freq = 1.0;

        for (let i = 0; i < octaves; i++) {
            const noiseValue = this.noise(x * freq, y * freq, z * freq);
            sum += (2 * Math.abs(noiseValue) - 1) * amp;

            freq *= lacunarity;
            amp *= gain;

            //adds some rotation to vary the textures more 
            x = x * Math.cos(0.5) + x*Math.sin(0.5);
            y = y * Math.sin(0.5) + y*Math.cos(0.5); 
        }

        return sum;
      }
    }

    class RidgedMultifractalNoise extends Noise {
      generateNoise(x, y, z, zoom = 1.0, octaves = 6, lacunarity = 2.0, gain = 0.75) {
        x /= zoom;
        y /= zoom;
        z /= zoom;

        let sum = 1 - Math.abs(this.noise(x, y, z));
        let amp = 1.0;

        for (let i = 1; i < octaves; i++) {
            x *= lacunarity;
            y *= lacunarity;
            z *= lacunarity;


            amp *= gain;
            sum -= (1 - Math.abs(this.noise(x, y, z))) * amp;
          
            //adds some rotation to vary the textures more 
            x = x * Math.cos(0.5) + x*Math.sin(0.5);
            y = y * Math.sin(0.5) + y*Math.cos(0.5); 
        }

        return sum;
      }
    }


    
    document.addEventListener('DOMContentLoaded', function() {
      const perlinCanvas = document.getElementById('perlinCanvas');
      const perlinCtx = perlinCanvas.getContext('2d');
      const billowCanvas = document.getElementById('billowCanvas');
      const billowCtx = billowCanvas.getContext('2d');
      const multifractalCanvas = document.getElementById('multifractalCanvas');
      const multifractalCtx = multifractalCanvas.getContext('2d');
      const fbmCanvas = document.getElementById('fbmCanvas');
      const fbmCtx = fbmCanvas.getContext('2d');
      const width = perlinCanvas.width;
      const height = perlinCanvas.height;

      const zoom = 100; // Adjust zoom for more zoomed-in noise pattern
      const octaves = 8; // Number of octaves for the noise
      const lacunarity = 2.0; // Lacunarity for the noise
      const gain = 0.5; // Gain for the noise
      const perlinHeightmap = new Float32Array(width * height);
      const billowHeightmap = new Float32Array(width * height);
      const ridgedHeightmap = new Float32Array(width * height);
      const fbmHeightmap = new Float32Array(width * height);
      const perlin = new PerlinNoise(12345); // Set a seed for reproducibility
      const billow = new BillowNoise(12345); // Set a seed for reproducibility
      const ridged = new RidgedMultifractalNoise(12345); // Set a seed for reproducibility
      const fbm = new FractalBrownianMotion(12345); // Set a seed for reproducibility

      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
      
            // Generate Perlin noise
            const noiseValue = perlin.generateNoise(x, y, 0, zoom, octaves, lacunarity, gain);
            perlinHeightmap[y * width + x] = noiseValue;

            const color = Math.floor((noiseValue + 1) * 128);
            perlinCtx.fillStyle = `rgb(${color}, ${color}, ${color})`;
            perlinCtx.fillRect(x, y, 1, 1);

            
            // Generate Billow noise
            const billowValue = billow.generateNoise(x, y, 0, zoom, octaves, lacunarity, gain - 0.2 > 0 ? gain - 0.2 : 0.01); // Slightly lower gain so effects are better looking
            billowHeightmap[y * width + x] = billowValue;

            const color2 = Math.floor((billowValue + 1) * 128);
            billowCtx.fillStyle = `rgb(${color2}, ${color2}, ${color2})`;
            billowCtx.fillRect(x, y, 1, 1);

            // Generate Ridged Multifractal noise
            const ridgedValue = ridged.generateNoise(x, y, 0, zoom, octaves, lacunarity, gain + 0.1 < 1 ? gain + 0.1 : 0.99); //slight increase in gain
            ridgedHeightmap[y * width + x] = ridgedValue;

            const color3 = Math.floor((ridgedValue + 1) * 128);
            multifractalCtx.fillStyle = `rgb(${color3}, ${color3}, ${color3})`;
            multifractalCtx.fillRect(x, y, 1, 1);

            // Generate SingleValueFractalFBM noise

            const fbmValue = fbm.generateNoise(x, y, 0, zoom, octaves, lacunarity, gain);//fbm.generateNoise(fbm.generateNoise(x,y,...inps),fbm.generateNoise(x,y,...inps),...inps);
            fbmHeightmap[y * width + x] = fbmValue;

            const color4 = Math.floor((fbmValue + 1) * 128);
            fbmCtx.fillStyle = `rgb(${color4}, ${color4}, ${color4})`;
            fbmCtx.fillRect(x, y, 1, 1);
        
        }
      
    }

    //   console.log('Perlin Heightmap:', perlinHeightmap);
    //   console.log('Billow Heightmap:', billowHeightmap);
    //   console.log('Ridged Heightmap:', ridgedHeightmap);
    //   console.log('FBM Heightmap:', fbmHeightmap);
    });
  </script>
</body>
</html>